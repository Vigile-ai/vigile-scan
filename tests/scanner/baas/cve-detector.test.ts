import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { parseNpmPackages, detectCves } from '../../../src/scanner/baas/cve-detector.js';
import type { DetectedPackage } from '../../../src/scanner/baas/cve-detector.js';

// ── parseNpmPackages (pure function, no mocking needed) ─────

describe('parseNpmPackages', () => {
  it('parses dependencies and devDependencies', () => {
    const json = JSON.stringify({
      name: 'my-app',
      dependencies: {
        react: '^18.2.0',
        'next': '14.1.0',
      },
      devDependencies: {
        typescript: '~5.3.3',
      },
    });

    const result = parseNpmPackages(json);
    expect(result).toHaveLength(3);

    const react = result.find((p) => p.name === 'react');
    expect(react).toBeDefined();
    expect(react!.version).toBe('18.2.0'); // ^ stripped
    expect(react!.ecosystem).toBe('npm');

    const next = result.find((p) => p.name === 'next');
    expect(next).toBeDefined();
    expect(next!.version).toBe('14.1.0'); // no prefix to strip

    const ts = result.find((p) => p.name === 'typescript');
    expect(ts).toBeDefined();
    expect(ts!.version).toBe('5.3.3'); // ~ stripped
  });

  it('strips semver range prefixes (^, ~, >=, <)', () => {
    const json = JSON.stringify({
      dependencies: {
        a: '^1.2.3',
        b: '~4.5.6',
        c: '>=7.0.0',
        d: '<2.0.0',
        e: '1.0.0',
      },
    });

    const result = parseNpmPackages(json);
    expect(result.find((p) => p.name === 'a')!.version).toBe('1.2.3');
    expect(result.find((p) => p.name === 'b')!.version).toBe('4.5.6');
    expect(result.find((p) => p.name === 'c')!.version).toBe('7.0.0');
    expect(result.find((p) => p.name === 'd')!.version).toBe('2.0.0');
    expect(result.find((p) => p.name === 'e')!.version).toBe('1.0.0');
  });

  it('handles scoped packages', () => {
    const json = JSON.stringify({
      dependencies: {
        '@supabase/supabase-js': '^2.39.0',
        '@firebase/app': '0.9.0',
      },
    });

    const result = parseNpmPackages(json);
    expect(result).toHaveLength(2);
    expect(result.find((p) => p.name === '@supabase/supabase-js')).toBeDefined();
    expect(result.find((p) => p.name === '@firebase/app')).toBeDefined();
  });

  it('returns empty array for invalid JSON', () => {
    expect(parseNpmPackages('not json')).toEqual([]);
    expect(parseNpmPackages('')).toEqual([]);
    expect(parseNpmPackages('{broken')).toEqual([]);
  });

  it('returns empty array when no dependencies exist', () => {
    const json = JSON.stringify({ name: 'empty-project', version: '1.0.0' });
    expect(parseNpmPackages(json)).toEqual([]);
  });

  it('sets ecosystem to npm for all packages', () => {
    const json = JSON.stringify({
      dependencies: { lodash: '4.17.21' },
    });
    const result = parseNpmPackages(json);
    expect(result[0].ecosystem).toBe('npm');
  });
});

// ── detectCves (requires fetch mocking) ─────────────────────

describe('detectCves', () => {
  let originalFetch: typeof globalThis.fetch;

  beforeEach(() => {
    originalFetch = globalThis.fetch;
  });

  afterEach(() => {
    globalThis.fetch = originalFetch;
    vi.restoreAllMocks();
  });

  it('returns empty results for empty package list', async () => {
    const result = await detectCves([]);
    expect(result.packagesChecked).toBe(0);
    expect(result.matches).toEqual([]);
    expect(result.findings).toEqual([]);
    expect(result.errors).toEqual([]);
  });

  it('skips packages with unknown ecosystem', async () => {
    const packages: DetectedPackage[] = [
      { name: 'mystery-pkg', version: '1.0.0', ecosystem: 'unknown' },
    ];
    const result = await detectCves(packages);
    expect(result.packagesChecked).toBe(1);
    expect(result.errors).toContain('No packages with valid version + ecosystem for CVE lookup');
  });

  it('skips packages with wildcard versions', async () => {
    const packages: DetectedPackage[] = [
      { name: 'some-pkg', version: '*', ecosystem: 'npm' },
    ];
    const result = await detectCves(packages);
    expect(result.errors).toContain('No packages with valid version + ecosystem for CVE lookup');
  });

  it('queries OSV.dev and returns findings for vulnerable packages', async () => {
    const mockOsvResponse = {
      results: [
        {
          vulns: [
            {
              id: 'GHSA-abcd-efgh-ijkl',
              summary: 'XSS vulnerability in test-pkg',
              aliases: ['CVE-2024-12345'],
              severity: [
                {
                  type: 'CVSS_V3',
                  score: 'CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N',
                },
              ],
              affected: [
                {
                  package: { name: 'test-pkg', ecosystem: 'npm' },
                  ranges: [
                    {
                      type: 'ECOSYSTEM',
                      events: [
                        { introduced: '0' },
                        { fixed: '2.0.1' },
                      ],
                    },
                  ],
                },
              ],
            },
          ],
        },
      ],
    };

    globalThis.fetch = vi.fn().mockResolvedValue({
      ok: true,
      status: 200,
      json: () => Promise.resolve(mockOsvResponse),
    } as unknown as Response);

    const packages: DetectedPackage[] = [
      { name: 'test-pkg', version: '1.5.0', ecosystem: 'npm' },
    ];

    const result = await detectCves(packages);

    expect(result.packagesChecked).toBe(1);
    expect(result.matches).toHaveLength(1);
    expect(result.findings).toHaveLength(1);

    // Should prefer CVE ID over GHSA
    expect(result.matches[0].cveId).toBe('CVE-2024-12345');
    expect(result.matches[0].patchedVersion).toBe('2.0.1');
    expect(result.matches[0].summary).toBe('XSS vulnerability in test-pkg');

    // Finding should use CVE ID
    const finding = result.findings[0];
    expect(finding.id).toBe('CVE-2024-12345');
    expect(finding.category).toBe('cve-detected');
    expect(finding.title).toContain('test-pkg@1.5.0');
    expect(finding.recommendation).toContain('2.0.1');
  });

  it('falls back to GHSA ID when no CVE alias exists', async () => {
    const mockOsvResponse = {
      results: [
        {
          vulns: [
            {
              id: 'GHSA-xxxx-yyyy-zzzz',
              summary: 'Prototype pollution',
              // No aliases
              affected: [
                {
                  package: { name: 'vuln-lib', ecosystem: 'npm' },
                  ranges: [{ type: 'ECOSYSTEM', events: [{ introduced: '0' }] }],
                },
              ],
            },
          ],
        },
      ],
    };

    globalThis.fetch = vi.fn().mockResolvedValue({
      ok: true,
      status: 200,
      json: () => Promise.resolve(mockOsvResponse),
    } as unknown as Response);

    const result = await detectCves([
      { name: 'vuln-lib', version: '3.0.0', ecosystem: 'npm' },
    ]);

    expect(result.matches[0].cveId).toBe('GHSA-xxxx-yyyy-zzzz');
    // No fix available
    expect(result.matches[0].patchedVersion).toBeNull();
    expect(result.findings[0].recommendation).toContain('No patched version available');
  });

  it('handles OSV.dev API errors gracefully', async () => {
    globalThis.fetch = vi.fn().mockResolvedValue({
      ok: false,
      status: 500,
    } as unknown as Response);

    const result = await detectCves([
      { name: 'some-pkg', version: '1.0.0', ecosystem: 'npm' },
    ]);

    expect(result.findings).toEqual([]);
    expect(result.errors).toContain('OSV.dev API returned HTTP 500');
  });

  it('handles fetch network errors gracefully', async () => {
    globalThis.fetch = vi.fn().mockRejectedValue(new Error('Network timeout'));

    const result = await detectCves([
      { name: 'some-pkg', version: '1.0.0', ecosystem: 'npm' },
    ]);

    expect(result.findings).toEqual([]);
    expect(result.errors.length).toBe(1);
    expect(result.errors[0]).toContain('Network timeout');
  });

  it('deduplicates vulns by preferred ID', async () => {
    const mockOsvResponse = {
      results: [
        {
          vulns: [
            {
              id: 'GHSA-aaaa-bbbb-cccc',
              summary: 'Vuln A',
              aliases: ['CVE-2024-00001'],
            },
            {
              // Same CVE, different GHSA — should be deduped
              id: 'GHSA-dddd-eeee-ffff',
              summary: 'Vuln A (duplicate)',
              aliases: ['CVE-2024-00001'],
            },
          ],
        },
      ],
    };

    globalThis.fetch = vi.fn().mockResolvedValue({
      ok: true,
      status: 200,
      json: () => Promise.resolve(mockOsvResponse),
    } as unknown as Response);

    const result = await detectCves([
      { name: 'dup-pkg', version: '1.0.0', ecosystem: 'npm' },
    ]);

    // Should only have 1 match, not 2
    expect(result.matches).toHaveLength(1);
    expect(result.matches[0].cveId).toBe('CVE-2024-00001');
  });

  it('maps CVSS scores to correct severity levels', async () => {
    // Test multiple vulns with different CVSS vectors
    const mockOsvResponse = {
      results: [
        {
          vulns: [
            {
              id: 'CVE-CRIT',
              summary: 'Critical RCE',
              severity: [{
                type: 'CVSS_V3',
                // AV:N (+1.5) + PR:N (+1.0) + C:H (+0.8) + I:H (+0.8) + A:H (+0.8) = 5+1.5+1+0.8+0.8+0.8 = 9.9 -> critical
                score: 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H',
              }],
            },
          ],
        },
        {
          vulns: [
            {
              id: 'CVE-LOW',
              summary: 'Info disclosure',
              // No severity data -> default 5.0 -> medium
            },
          ],
        },
      ],
    };

    globalThis.fetch = vi.fn().mockResolvedValue({
      ok: true,
      status: 200,
      json: () => Promise.resolve(mockOsvResponse),
    } as unknown as Response);

    const result = await detectCves([
      { name: 'pkg-a', version: '1.0.0', ecosystem: 'npm' },
      { name: 'pkg-b', version: '2.0.0', ecosystem: 'npm' },
    ]);

    const critFinding = result.findings.find((f) => f.id === 'CVE-CRIT');
    expect(critFinding).toBeDefined();
    expect(critFinding!.severity).toBe('critical');

    const medFinding = result.findings.find((f) => f.id === 'CVE-LOW');
    expect(medFinding).toBeDefined();
    expect(medFinding!.severity).toBe('medium'); // default 5.0 -> medium
  });

  it('handles packages with no vulnerabilities', async () => {
    const mockOsvResponse = {
      results: [
        { vulns: [] }, // no vulns for this package
      ],
    };

    globalThis.fetch = vi.fn().mockResolvedValue({
      ok: true,
      status: 200,
      json: () => Promise.resolve(mockOsvResponse),
    } as unknown as Response);

    const result = await detectCves([
      { name: 'safe-pkg', version: '1.0.0', ecosystem: 'npm' },
    ]);

    expect(result.packagesChecked).toBe(1);
    expect(result.matches).toEqual([]);
    expect(result.findings).toEqual([]);
    expect(result.errors).toEqual([]);
  });
});
