// ============================================================
// Vigile CLI — CVE Detector
// Checks detected npm/pypi/cargo packages against the OSV.dev
// vulnerability database (free, no API key required).
// ============================================================
//
// Finding IDs:
//   CVE-*   Direct CVE from OSV.dev database         — severity varies
//   GHSA-*  GitHub Security Advisory                  — severity varies
//
// API reference: https://osv.dev/docs/#tag/api/post/v1/querybatch
// ============================================================

import type { Finding } from '../../types/index.js';

const FETCH_TIMEOUT_MS = 15_000;
const OSV_BATCH_URL = 'https://api.osv.dev/v1/querybatch';
const MAX_BATCH_SIZE = 100; // OSV recommends batches of ≤1000, we cap lower

export interface DetectedPackage {
  /** Package name (npm, PyPI, etc.) */
  name: string;
  /** Detected version string */
  version: string;
  /** Ecosystem: npm, pypi, cargo, etc. */
  ecosystem: 'npm' | 'pypi' | 'cargo' | 'unknown';
}

export interface CveMatch {
  pkg: DetectedPackage;
  cveId: string;
  cvssScore: number;
  summary: string;
  patchedVersion: string | null;
}

export interface CveDetectionResult {
  packagesChecked: number;
  matches: CveMatch[];
  findings: Finding[];
  errors: string[];
}

// ── Fetch with timeout ──────────────────────────────────────

async function fetchWithTimeout(
  url: string,
  init?: RequestInit,
): Promise<Response> {
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), FETCH_TIMEOUT_MS);
  try {
    return await fetch(url, { ...init, signal: controller.signal });
  } finally {
    clearTimeout(timer);
  }
}

// ── OSV.dev response types ──────────────────────────────────

interface OsvSeverity {
  type: string;
  score: string;
}

interface OsvAffectedRange {
  type: string;
  events: Array<{ introduced?: string; fixed?: string; last_affected?: string }>;
}

interface OsvAffectedPackage {
  package: { name: string; ecosystem: string };
  ranges?: OsvAffectedRange[];
  versions?: string[];
}

interface OsvVuln {
  id: string;
  summary?: string;
  details?: string;
  severity?: OsvSeverity[];
  affected?: OsvAffectedPackage[];
  aliases?: string[];
}

interface OsvBatchResponse {
  results: Array<{ vulns?: OsvVuln[] }>;
}

// ── CVSS score extraction ───────────────────────────────────

/**
 * Extract a numeric CVSS score from OSV severity data.
 * OSV provides severity as CVSS_V3 or CVSS_V2 vector strings
 * (e.g. "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H").
 * We parse the base score from the vector or fall back to a
 * heuristic based on the severity label.
 */
function extractCvssScore(vuln: OsvVuln): number {
  if (vuln.severity && vuln.severity.length > 0) {
    for (const sev of vuln.severity) {
      // Try to extract numeric score from CVSS vector
      const scoreMatch = sev.score.match(/CVSS:[^/]+\/.*?/);
      if (scoreMatch && sev.type === 'CVSS_V3') {
        // Parse AV/AC/PR/UI/S/C/I/A components for rough score estimation
        // For simplicity, use the ecosystem_specific database_specific severity
        return estimateCvssFromVector(sev.score);
      }
    }
  }
  // Default: unknown severity
  return 5.0;
}

/**
 * Rough CVSS 3.x score estimation from a vector string.
 * Full CVSS calculation is complex — we approximate from key metrics.
 */
function estimateCvssFromVector(vector: string): number {
  const v = vector.toUpperCase();

  // Attack vector
  const avNetwork = v.includes('/AV:N');
  // Privileges required
  const prNone = v.includes('/PR:N');
  // Confidentiality / Integrity / Availability impact
  const cHigh = v.includes('/C:H');
  const iHigh = v.includes('/I:H');
  const aHigh = v.includes('/A:H');
  const cLow = v.includes('/C:L');
  const iLow = v.includes('/I:L');
  const aLow = v.includes('/A:L');

  let score = 5.0; // base
  if (avNetwork) score += 1.5;
  if (prNone) score += 1.0;
  if (cHigh) score += 0.8;
  if (iHigh) score += 0.8;
  if (aHigh) score += 0.8;
  if (cLow) score += 0.3;
  if (iLow) score += 0.3;
  if (aLow) score += 0.3;

  return Math.min(10.0, Math.round(score * 10) / 10);
}

/**
 * Extract the earliest fixed version from affected range events.
 */
function extractPatchedVersion(vuln: OsvVuln, pkgName: string): string | null {
  if (!vuln.affected) return null;

  for (const affected of vuln.affected) {
    if (affected.package.name !== pkgName) continue;
    if (!affected.ranges) continue;

    for (const range of affected.ranges) {
      for (const event of range.events) {
        if (event.fixed) return event.fixed;
      }
    }
  }
  return null;
}

/**
 * Get a preferred vulnerability ID — prefer CVE IDs over GHSA/OSV IDs.
 */
function getPreferredId(vuln: OsvVuln): string {
  // Check aliases for a CVE ID first
  if (vuln.aliases) {
    const cve = vuln.aliases.find((a) => a.startsWith('CVE-'));
    if (cve) return cve;
  }
  // Fall back to the primary ID (GHSA-xxx or OSV-xxx)
  return vuln.id;
}

// ── Severity mapping ────────────────────────────────────────

function cvssToSeverity(score: number): 'critical' | 'high' | 'medium' | 'low' {
  if (score >= 9.0) return 'critical';
  if (score >= 7.0) return 'high';
  if (score >= 4.0) return 'medium';
  return 'low';
}

// ── Main export ─────────────────────────────────────────────

/**
 * Checks a list of detected packages against the OSV.dev
 * vulnerability database.
 *
 * Scan flow:
 *   1. Build batch query from package list
 *   2. POST to OSV.dev /v1/querybatch
 *   3. Parse vulnerability records into CveMatch objects
 *   4. Build Finding objects for each match
 *
 * @param packages  List of packages detected in the scanned app
 */
export async function detectCves(packages: DetectedPackage[]): Promise<CveDetectionResult> {
  const matches: CveMatch[] = [];
  const findings: Finding[] = [];
  const errors: string[] = [];

  if (packages.length === 0) {
    return { packagesChecked: 0, matches, findings, errors };
  }

  // Filter out packages with non-parseable versions or 'unknown' ecosystem
  const queryablePackages = packages.filter(
    (p) => p.ecosystem !== 'unknown' && p.version && !p.version.includes('*'),
  );

  if (queryablePackages.length === 0) {
    errors.push('No packages with valid version + ecosystem for CVE lookup');
    return { packagesChecked: packages.length, matches, findings, errors };
  }

  // Batch into chunks of MAX_BATCH_SIZE
  const chunks: DetectedPackage[][] = [];
  for (let i = 0; i < queryablePackages.length; i += MAX_BATCH_SIZE) {
    chunks.push(queryablePackages.slice(i, i + MAX_BATCH_SIZE));
  }

  for (const chunk of chunks) {
    // Build OSV batch query
    const queries = chunk.map((pkg) => ({
      package: {
        name: pkg.name,
        ecosystem: pkg.ecosystem === 'npm' ? 'npm' : pkg.ecosystem === 'pypi' ? 'PyPI' : pkg.ecosystem,
      },
      version: pkg.version,
    }));

    try {
      const res = await fetchWithTimeout(OSV_BATCH_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ queries }),
      });

      if (!res.ok) {
        errors.push(`OSV.dev API returned HTTP ${res.status}`);
        continue;
      }

      const body = (await res.json()) as OsvBatchResponse;

      // Each result corresponds to the query at the same index
      for (let i = 0; i < body.results.length; i++) {
        const result = body.results[i];
        const pkg = chunk[i];
        if (!result?.vulns || result.vulns.length === 0) continue;

        // Deduplicate vulns by preferred ID (CVE > GHSA > OSV)
        const seenIds = new Set<string>();

        for (const vuln of result.vulns) {
          const vulnId = getPreferredId(vuln);
          if (seenIds.has(vulnId)) continue;
          seenIds.add(vulnId);

          const cvssScore = extractCvssScore(vuln);
          const patchedVersion = extractPatchedVersion(vuln, pkg.name);
          const summary = vuln.summary ?? vuln.details?.slice(0, 200) ?? 'No description available';

          const match: CveMatch = {
            pkg,
            cveId: vulnId,
            cvssScore,
            summary,
            patchedVersion,
          };
          matches.push(match);

          const severity = cvssToSeverity(cvssScore);
          findings.push({
            id: vulnId,
            category: 'cve-detected',
            severity,
            title: `${vulnId}: ${pkg.name}@${pkg.version}`,
            description:
              `Known vulnerability in ${pkg.name} version ${pkg.version}. ` +
              `${summary.slice(0, 300)}`,
            evidence:
              `Package: ${pkg.name}@${pkg.version} (${pkg.ecosystem}) | ` +
              `CVSS: ${cvssScore} | ` +
              (patchedVersion ? `Fixed in: ${patchedVersion}` : 'No patch available'),
            recommendation: patchedVersion
              ? `Upgrade ${pkg.name} to version ${patchedVersion} or later. ` +
                `Run: npm install ${pkg.name}@${patchedVersion}`
              : `No patched version available. Consider removing or replacing ` +
                `${pkg.name} with an alternative package. Monitor ${vulnId} for updates.`,
          });
        }
      }
    } catch (err: unknown) {
      const msg = err instanceof Error ? err.message : String(err);
      errors.push(`OSV.dev query failed: ${msg}`);
    }
  }

  return {
    packagesChecked: packages.length,
    matches,
    findings,
    errors,
  };
}

/**
 * Parses package.json text and returns detected npm packages.
 * Used by vibe-app-scanner to extract dependencies from fetched
 * package.json files or bundle metadata.
 */
export function parseNpmPackages(packageJsonText: string): DetectedPackage[] {
  try {
    const parsed = JSON.parse(packageJsonText) as Record<string, unknown>;
    const deps = {
      ...((parsed.dependencies as Record<string, string>) ?? {}),
      ...((parsed.devDependencies as Record<string, string>) ?? {}),
    };
    return Object.entries(deps).map(([name, version]) => ({
      name,
      version: String(version).replace(/^[\^~>=<]+/, ''), // strip semver range prefixes
      ecosystem: 'npm' as const,
    }));
  } catch {
    return [];
  }
}
